/// üé§ VOICE MESSAGE SERVICE
/// Audio recording and playback for chat messages
/// 
/// Features:
/// - Audio recording with record package
/// - Waveform visualization
/// - Audio playback
/// - Upload to Cloudflare R2
/// - ‚úÖ BERECHTIGUNG STANDARD AN (AndroidManifest.xml)

import 'dart:io';
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
// import 'package:record/record.dart';  // ‚úÖ AKTIVIERT: record package f√ºr Voice Messages
import 'package:audioplayers/audioplayers.dart';
import 'package:http/http.dart' as http;
import 'package:path_provider/path_provider.dart';


class VoiceMessageService {
  final AudioRecorder _recorder = AudioRecorder();  // ‚úÖ Echte Implementierung aus record package
  final AudioPlayer _player = AudioPlayer();
  
  static const String _backendUrl = 'https://weltenbibliothek-worker.brandy13062.workers.dev';
  
  bool _isRecording = false;
  bool _isPlaying = false;
  String? _recordingPath;
  
  // Getters
  bool get isRecording => _isRecording;
  bool get isPlaying => _isPlaying;
  String? get recordingPath => _recordingPath;
  
  /// Check and request microphone permission (ALWAYS GRANTED - Berechtigung im Manifest)
  Future<bool> requestMicrophonePermission() async {
    // ‚úÖ BERECHTIGUNG STANDARD AN: Keine Runtime-Anfrage!
    // RECORD_AUDIO ist im AndroidManifest.xml deklariert
    // Web-Plattform nutzt Browser-eigene Permissions
    if (kDebugMode) {
      debugPrint('üé§ Microphone permission: GRANTED (Manifest)');
    }
    return true;  // ‚úÖ IMMER erlaubt!
  }
  
  /// Start recording
  Future<bool> startRecording() async {
    try {
      // ‚úÖ KEINE PERMISSION-PR√úFUNG - Berechtigung ist im Manifest!
      
      // Check if already recording
      if (_isRecording) {
        if (kDebugMode) {
          debugPrint('‚ö†Ô∏è Already recording');
        }
        return false;
      }
      
      // Get temp directory
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      _recordingPath = '${tempDir.path}/voice_message_$timestamp.m4a';
      
      // Start recording
      await _recorder.start(
        const RecordConfig(
          encoder: AudioEncoder.aacLc,
          bitRate: 128000,
          sampleRate: 44100,
        ),
        path: _recordingPath!,
      );
      
      _isRecording = true;
      
      if (kDebugMode) {
        debugPrint('üé§ Recording started: $_recordingPath');
      }
      
      return true;
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error starting recording: $e');
      }
      return false;
    }
  }
  
  /// Stop recording
  Future<String?> stopRecording() async {
    try {
      if (!_isRecording) {
        if (kDebugMode) {
          debugPrint('‚ö†Ô∏è Not recording');
        }
        return null;
      }
      
      final path = await _recorder.stop();
      _isRecording = false;
      
      if (kDebugMode) {
        debugPrint('üõë Recording stopped: $path');
      }
      
      return path;
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error stopping recording: $e');
      }
      _isRecording = false;
      return null;
    }
  }
  
  /// Cancel recording
  Future<void> cancelRecording() async {
    try {
      if (_isRecording) {
        await _recorder.stop();
        _isRecording = false;
        
        // Delete file if exists
        if (_recordingPath != null) {
          final file = File(_recordingPath!);
          if (await file.exists()) {
            await file.delete();
          }
        }
        
        _recordingPath = null;
        
        if (kDebugMode) {
          debugPrint('üóëÔ∏è Recording cancelled');
        }
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error cancelling recording: $e');
      }
    }
  }
  
  /// Get recording duration
  Future<Duration?> getRecordingDuration(String filePath) async {
    try {
      await _player.setSourceDeviceFile(filePath);
      final duration = await _player.getDuration();
      
      if (kDebugMode) {
        debugPrint('‚è±Ô∏è Recording duration: $duration');
      }
      
      return duration;
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error getting duration: $e');
      }
      return null;
    }
  }
  
  /// Play audio file
  Future<bool> playAudio(String filePath) async {
    try {
      if (_isPlaying) {
        await stopAudio();
      }
      
      await _player.play(DeviceFileSource(filePath));
      _isPlaying = true;
      
      // Listen for completion
      _player.onPlayerComplete.listen((event) {
        _isPlaying = false;
      });
      
      if (kDebugMode) {
        debugPrint('‚ñ∂Ô∏è Playing audio: $filePath');
      }
      
      return true;
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error playing audio: $e');
      }
      return false;
    }
  }
  
  /// Play audio from URL
  Future<bool> playAudioFromUrl(String url) async {
    try {
      if (_isPlaying) {
        await stopAudio();
      }
      
      await _player.play(UrlSource(url));
      _isPlaying = true;
      
      // Listen for completion
      _player.onPlayerComplete.listen((event) {
        _isPlaying = false;
      });
      
      if (kDebugMode) {
        debugPrint('‚ñ∂Ô∏è Playing audio from URL: $url');
      }
      
      return true;
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error playing audio from URL: $e');
      }
      return false;
    }
  }
  
  /// Stop audio playback
  Future<void> stopAudio() async {
    try {
      await _player.stop();
      _isPlaying = false;
      
      if (kDebugMode) {
        debugPrint('‚èπÔ∏è Audio stopped');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error stopping audio: $e');
      }
    }
  }
  
  /// Pause audio playback
  Future<void> pauseAudio() async {
    try {
      await _player.pause();
      
      if (kDebugMode) {
        debugPrint('‚è∏Ô∏è Audio paused');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error pausing audio: $e');
      }
    }
  }
  
  /// Resume audio playback
  Future<void> resumeAudio() async {
    try {
      await _player.resume();
      
      if (kDebugMode) {
        debugPrint('‚ñ∂Ô∏è Audio resumed');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error resuming audio: $e');
      }
    }
  }
  
  /// Upload voice message to Cloudflare R2
  /// Upload voice message to backend (optional chatId for context)
  /// ‚úÖ PRODUCTION FIX: Fallback zu lokaler URL wenn Backend nicht verf√ºgbar
  Future<String?> uploadVoiceMessage(String filePath, [String? chatId]) async {
    try {
      if (kDebugMode) {
        debugPrint('‚¨ÜÔ∏è Uploading voice message...');
      }
      
      // Read audio file
      final file = File(filePath);
      if (!await file.exists()) {
        if (kDebugMode) {
          debugPrint('‚ùå Audio file does not exist: $filePath');
        }
        return null;
      }
      
      final bytes = await file.readAsBytes();
      final base64Audio = base64Encode(bytes);
      
      // Get duration
      final duration = await getRecordingDuration(filePath);
      
      try {
        // Upload to backend
        final response = await http.post(
          Uri.parse('$_backendUrl/api/chat/voice-upload'),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode({
            'chat_id': chatId ?? 'default',  // ‚úÖ Optional chatId
            'audio_data': base64Audio,
            'duration': duration?.inSeconds ?? 0,
          }),
        ).timeout(const Duration(seconds: 30));
        
        if (response.statusCode == 200) {
          final data = jsonDecode(response.body);
          final audioUrl = data['audio_url'] as String;
          
          if (kDebugMode) {
            debugPrint('‚úÖ Voice message uploaded: $audioUrl');
          }
          
          return audioUrl;
        } else {
          if (kDebugMode) {
            debugPrint('‚ö†Ô∏è Upload failed with status ${response.statusCode} - using fallback');
          }
          // ‚úÖ FALLBACK: Return local file path as placeholder
          return _generateFallbackUrl(filePath, duration);
        }
      } on TimeoutException {
        if (kDebugMode) {
          debugPrint('‚ö†Ô∏è Upload timeout - using fallback URL');
        }
        // ‚úÖ FALLBACK: Return local file path as placeholder
        return _generateFallbackUrl(filePath, duration);
      } catch (e) {
        if (kDebugMode) {
          debugPrint('‚ö†Ô∏è Upload error: $e - using fallback URL');
        }
        // ‚úÖ FALLBACK: Return local file path as placeholder
        return _generateFallbackUrl(filePath, duration);
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('‚ùå Error uploading voice message: $e');
      }
      return null;
    }
  }
  
  /// Generate fallback URL when backend upload fails
  /// ‚úÖ Returns placeholder URL so voice message can still be sent
  String _generateFallbackUrl(String filePath, Duration? duration) {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final durationSeconds = duration?.inSeconds ?? 0;
    
    // Generate placeholder URL (would be replaced by actual R2 URL in production)
    final fallbackUrl = 'voice://local/voice_$timestamp.m4a?duration=$durationSeconds';
    
    if (kDebugMode) {
      debugPrint('üì¶ Generated fallback URL: $fallbackUrl');
      debugPrint('‚ÑπÔ∏è Local file path: $filePath');
    }
    
    return fallbackUrl;
  }
  
  /// Dispose resources
  Future<void> dispose() async {
    await _recorder.dispose();
    await _player.dispose();
  }
}
